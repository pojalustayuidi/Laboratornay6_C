# Указатели
# Задание 1
Предположим, что в функции main() определены три локальных массива одинакового размера и типа (скажем, float). Первые два уже инициализированы значениями. Напишите функцию addarrays(), которая принимает в качестве аргументов адреса грех массивов, складывает соответствующие элементы двух массивов и помещает результат в третий массив. Четвертым аргументом этой функции может быть размерность массивов. На всем протяжении программы используйте указатели.
# Вывод 1
![image](https://github.com/user-attachments/assets/245532d0-a908-4815-9d7b-b126a5da40ed)

# Задание 2
Создайте свою версию библиотечной функции strcmp(s1, s2), которая сравнивает две строки и возвращает -1, если s1 идет первой по алфавиту, 0, если в s1 и s2 одинаковые значения, и 1, если s2 идет первой по алфавиту. Назовите вашу функцию compstr(). Она должна принимать в качестве аргументов два указателя на строки char *, сравнивать эти строки посимвольно и возвращать число int. Напишите функцию main() для проверки работы вашей функции с разными строками. Используйте указатели во всех возможных ситуациях.
# Вывод 2
![image](https://github.com/user-attachments/assets/6fb34108-8f26-46f7-91bd-11804ba3b149)

# Задание 3
Допустим, что нам нужно сохранить 100 целых чисел так, чтобы иметь к ним легкий доступ. Допустим, что при этом у нас есть проблема: память нашего компьютера так фрагментирована, что может хранить массив, наибольшее количество элементов в котором равно десяти (такие проблемы действительно появляются, хотя обычно это происходит с объектами, занимающими большое количество памяти). Вы можете решить эту проблему, определив 10 разных массивов по 10 элементов в каждом и массив из 10 указателей на эти массивы. Массивы будут иметь имена а0, a1, а2 и т. д. Адрес каждого массива будет сохранен в массиве указателей типа int*, который называется ар. Вы сможете получить доступ к отдельному целому используя выражение ap[j] [к], где j является номером элемента массива указателей, а к — номером элемента в массиве, на который этот указатель указывает. Это похоже на двумерный массив, но в действительности является группой одномерных массивов.
Заполните группу массивов тестовыми данными (скажем, номерами 0, 10, 20 и т. д.), а затем выведите их, чтобы убедиться, что все работает правильно.

# Вывод 3
![image](https://github.com/user-attachments/assets/82c89b5a-b463-4f61-a78b-7ceaba0adef0)

# Задание 4
Описанный в упражнении 3 подход нерационален, так как каждый из 10 массивов объявляется отдельно, с использованием отдельного имени, и каждый адрес получают отдельно. Вы можете упростить программу, используя операцию new, которая позволит вам выделить память для массивов в цикле и одновременно связать с ними указатели:
for ( j = 0: j < NUMARRAYS; j++ )	// создаем NUMARRAYS массивов
*( ар + j ) = new int [ MAXSIZE ]: //no MAXSIZE целых чисел в каждом
Перепишите программу упражнения 3, используя этот подход. Доступ к отдельному элементу массивов вы сможете получить, используя то же выражение, что и в упражнении 3, или аналогичное выражение с указателями: *(*(ap+j)+k).

# Вывод 4
![image](https://github.com/user-attachments/assets/41a39b5e-b83a-483c-b6eb-dbc8bb9a7302)

# Задание 5
Создайте структуру person хранящую информацию об имени и зарплате сотрудников. Для хранения имени использовать указатель на данные типа char. Создайте указатель на данные типа person. Выделите память оператором new для хранения информации о пяти сотрудниках и сохраните адрес ее начала в указателе. Создайте функции для ввода данных о сотрудниках (для хранения имени выделять память динамически и сохранять указатель на нее в соответствующем поле структуры), выводе данных о сотрудниках на экран, сортировки указателей в динамической памяти на сотрудников по величине зарплаты. Проверить работу программы последовательностью операций: Ввод информации о пяти сотрудниках, вывод информации о них на экран, сортировка, вывод информации о сотрудниках на экран.
# Вывод 5
![image](https://github.com/user-attachments/assets/d748bd4e-24fa-4e0e-bcc2-360045d3e678)

